
значимые
1. Примитивные типы: int, long, short, byte;
2. Вещественные: float, double, decimal
3. символьный: char
4. булевый: bool
5. Структуры: struct
6. Перечисления: enum

Ссылочные
1. Классы
2. Интерфейсы
3. Массивы
4. Строки
5. Делегаты


Ограничения (constraints) могут быть наложены на параметр типа T для уточнения допустимых типов. Например, можно использовать 
ограничения для указания, что T должен быть классом, иметь конструктор по умолчанию и т.д.

Пример использования ограничений:

csharp
Copy code
public class Box<T> where T : class, new()
{
    private T value;

    public void Add(T newValue)
    {
        value = newValue;
    }

    public T GetValue()
    {
        return value;
    }
}
В этом примере, с использованием where T : class, new(), мы ограничиваем T так, что он должен быть ссылочным типом (class) и 
иметь конструктор по умолчанию (new()).

Некоторые общие ограничения (constraints) в C#:

where T : class: T должен быть ссылочным типом.
where T : struct: T должен быть значимым типом (структурой).
where T : new(): T должен иметь конструктор по умолчанию.
where T : базовый_тип: T должен быть или наследоваться от базовый_тип.
where T : интерфейс: T должен реализовывать указанный интерфейс.


public delegate string MyDelegate(string str1, string str2);

public class DelegateExample
{
    public static void Main2()
    {
        MyDelegate myDel = ConcatStrings;

        UseDelegate(myDel);

    }

    public static string ConcatStrings(string str1, string str2)
    {
        return str1 + str2;
    }

    public static void UseDelegate(MyDelegate myDel)
    {
        string result = myDel("a", "b");
        Console.WriteLine(result);
    }
}


Оператор is используется для проверки типа объекта. Он возвращает true, если объект является экземпляром указанного типа, и false в противном случае. Пример:

csharp
Copy code
object myObject = "Hello, World!";

if (myObject is string)
{
    Console.WriteLine("myObject является строкой.");
}
else
{
    Console.WriteLine("myObject не является строкой.");
}
as:
Оператор as используется для приведения типа объекта к другому типу, если это приведение возможно. Если приведение типа не удается, то результат будет null. Пример:

csharp
Copy code
object myObject = "Hello, World!";

string myString = myObject as string;

if (myString != null)
{
    Console.WriteLine("Приведение типа прошло успешно: " + myString);
}
else
{
    Console.WriteLine("Не удалось привести тип.");
}


Ограничения методов расширения:
Методы расширения могут быть определены только в статических классах.
Они должны быть статическими и определены в статическом классе.
Первый параметр метода должен иметь ключевое слово this перед типом, который будет расширен.

ref и out - это ключевые слова в C#, которые используются для передачи параметров в методы с особым образом. Они позволяют изменять значения переменных в вызывающем коде через вызванный метод. Вот как они работают:

ref:
ref используется для передачи параметра методу так, чтобы он ссылался на тот же объект в памяти, что и оригинальная переменная.
Метод может изменять значение переменной, на которую ссылаются ref параметры.
Пример:

csharp
Copy code
void ModifyValue(ref int x)
{
    x = x * 2;
}

int number = 5;
ModifyValue(ref number);
Console.WriteLine(number); // Выведет "10"
out:
out также используется для передачи параметра методу, но в отличие от ref, не требует, чтобы переменная была инициализирована перед передачей в метод.
Метод должен присвоить значение переменной out в теле метода, прежде чем он завершится.
Пример:

csharp
Copy code
void InitializeAndDouble(out int y)
{
    y = 5;
    y = y * 2;
}

int result;
InitializeAndDouble(out result);
Console.WriteLine(result); // Выведет "10"
Обратите внимание, что при использовании out необязательно инициализировать переменную до передачи ее в метод.

Особенности:
Статические члены принадлежат классу, а не конкретному экземпляру, и поэтому они разделяются всеми экземплярами 
класса и доступны без создания экземпляра.
Нельзя обращаться к экземплярным членам из статических методов или полей.
Статические методы и поля используются, например, для предоставления общих ресурсов, к которым нужен доступ без 
создания экземпляра класса, или для выполнения операций, не зависящих от конкретного объекта.

public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    public static Point operator +(Point p1, Point p2)
    {
        return new Point(p1.X + p2.X, p1.Y + p2.Y);
    }
}


public class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }

    public double Add(double a, double b)
    {
        return a + b;
    }

};

public class Shape
{
    public virtual void Draw()
    {
        Console.WriteLine("Drawing a shape");
    }
}

public class Circle : Shape
{
    public override sealed void Draw()
    {
        Console.WriteLine("Drawing a circle");
    }
}


public abstract class DoSmth
{
    public abstract void Act();
}

public class SubDo : DoSmth
{

    object person = new
    {
        FirstName = "John",
        Age = 30
    };

    public override void Act()
    {
        Console.WriteLine("Something");

    }

    public object CreatePerson()
    {
        return new
        {
            FirstName = "John",
            Age = 30
        };
    }
}

public class MainClass
{
    public static void Main(string[] args)
    {
        Circle circle = new Circle();
        circle.Draw();
    }
}


public class Box<T> where T: class, new()
{
    private T value;

    public void Add(T newValue)
    {
        value = newValue;
    }

    public T GetValue()
    {
        return value;
    }

}


public interface IDrawable
{
    void Draw();
}

public class Circl : IDrawable
{
    public void Draw()
    {
        Console.WriteLine("Drawing");
    }

}



public delegate string MyDelegate(string str1, string str2);

public class DelegateExample
{
    public static void Main2()
    {
        MyDelegate myDel = ConcatStrings;

        UseDelegate(myDel);

    }

    public static string ConcatStrings(string str1, string str2)
    {
        return str1 + str2;
    }

    public static void UseDelegate(MyDelegate myDel)
    {
        string result = myDel("a", "b");
        Console.WriteLine(result);
    }
}

public enum Status
{
    OK = 200,
    BAD_REQUEST = 400,
    FORBIDDEN = 403,
    NOT_FOUND = 404
}

public class MyCustymException : Exception
{
    public MyCustymException(string message) : base()
    {
        
    }
}

public class TryMyException
{
    public void Do()
    {
        throw new MyCustymException("My exception");
        throw new Exception("New exeption");

        object myObject = "Hello World!";

        if(myObject is string)
        {
            Console.WriteLine("Its string");
            string myString = myObject as string;
        }
        else
        {
            Console.WriteLine("its not string");
        }


        string str = "Hello";
        str.DeleterFirstLetter();
    }
}

public static class StringExtentions
{
    public static string DeleterFirstLetter(this string input)
    {
        return input.Substring(1);
    }
}


public class Singleton
{
    private static Singleton instance;

    private Singleton()
    {

    }

    public static Singleton getSingleton()
    {
        if(instance == null)
        {
            return new Singleton();
        }
        return instance;
    }
}

public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    public static Point operator +(Point p1, Point p2)
    {
        return new Point(p1.X + p2.X, p1.Y + p2.Y);
    }
}